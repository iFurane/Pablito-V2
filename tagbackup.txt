# Tag functionality:
#   Tags can only be accessed, edited, and deleted from their specific categories
#   If tag category is set to 'all': all categories can access the tag
#   Only full time mods and admins can edit 'all' category tags
#   Only people with 'TagEdit' role can edit tags.
#   only people with 'TagRecall' role can recall tags.
# -tagcreate, -tc : create a tag
@bot.command(name='tagcreate')
async def tag_create(ctx, *args):
    if len(args) == 0:
        await react_neg(ctx)
        await ctx.reply(f'Nothing specified',delete_after=reply_data['tag_error']['timeout'])
        return
    try:
        vals = shlex.split(' '.join(args))
    except:
        await ctx.reply('Syntax error')
        return
    if len(vals) == 1:
        await react_neg(ctx)
        await ctx.reply(f'No content given', delete_after=reply_data['tag_error']['timeout'])
        return

    stat = tag.tag_create(name=vals[0],author=ctx.author,content=' '.join(vals[1:]),date=datetime.datetime.utcnow(), category=ctx.channel.category)
    if stat is True:
        await ctx.message.add_reaction('âœ…')
    else:
        await react_neg(ctx)
        await ctx.reply(f'Tag already exists',delete_after=reply_data['tag_error']['timeout'])


# -tag, -t : recall the tag
@bot.command(name='tag')
async def tag_recall(ctx, *args):
    if len(args)==0:
        await react_neg(ctx)
        await ctx.reply(f'No name specified',delete_after=reply_data['tag_error']['timeout'])
        return
    tg = tag.recall_tag(' '.join(args))
    if tg is None:
        await ctx.reply(f'Tag does not exist: {name}',delete_after=reply_data['tag_error']['timeout'])
    elif tg['category'] != str(ctx.channel.category):
        print('ignored')
        return
    else:
        await ctx.reply(tg['content'])


# -tagedit, -te : edit the tag
@bot.command(name='tagedit')
async def tag_edit(ctx, *args):
    if len(args) == 0:
        await react_neg(ctx)
        await ctx.reply(f'Nothing specified',delete_after=reply_data['tag_error']['timeout'])
        return
    try:
        vals = shlex.split(' '.join(args))
    except:
        await ctx.reply('Syntax error') #add syntax error embed later
        return
    if len(vals) == 1:
        await react_neg(ctx)
        await ctx.reply(f'No content given', delete_after=reply_data['tag_error']['timeout'])
        return




# -tagdelete, -td : delete a tag
@bot.command(name='tagdelete')
async def tag_delete(ctx, name=''):
    if name == '':
        await react_neg(ctx)
        await ctx.reply(f'Give a name, bruh',delete_after=reply_data['tag_error']['timeout'])
        return
    else:
        stat = tag.tag_delete(name)
        if stat:
            await react_pos(ctx)
        else:
            await ctx.reply(f'Tag does not exist',delete_after=reply_data['tag_error']['timeout'])


# -taginfo, -ti : show info about given tag
@bot.command('taginfo')
async def tag_info(ctx, *args):
    name = ' '.join(args)
    tags = tag.recall_tag(name)
    if tags is None:
        await react_neg(ctx)
        await ctx.reply('Tag does not exist',delete_after=reply_data['tag_error']['timeout'])
        return
    embed = discord.Embed(title=f'{name}',
                          description=f'Author: {tags["author"]}\n'
                                      f'Creation time: {tags["date"]}',
                          color=colors_data['DEFAULT'])
    embed.set_footer(text=f'{ctx.author} at {datetime.datetime.utcnow()} UTC')
    react_pos(ctx)
    await ctx.reply(embed=embed)


# -taglist, -tl : list all tags
@bot.command(name='taglist')
async def tag_list(ctx, *args):
    if args[0] != 'all' and lst[0] == '0':
        await ctx.reply(embed=discord.Embed(title='No tags in this category',color=colors_data['DEFAULT']),
                        delete_after=reply_data['tag_error']['timeout'])
        return
    elif args[0] == 'all' and lst[0] == '0':
        await ctx.reply(embed=discord.Embed(title='No tags in the server', color=colors_data['DEFAULT']),
                        delete_after=reply_data['tag_error']['timeout'])
        return
    elif args[0] == 'all' and lst[0] != '0':
        lst = tag.tag_list()


    embed = discord.Embed(title=f'All tags ({lst[0]})',
                          description=f'{lst[1]}',
                          color=colors_data['DEFAULT'])
    embed.set_footer(text=f'{ctx.author} at {datetime.datetime.utcnow()} UTC')
    await ctx.reply(embed=embed)
